import ccxt
import time
import json
import requests
import os
from datetime import datetime
import pytz
from threading import Thread
import math

# ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØ±ØµØ© ÙˆØ§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… =====
api_key = 'sE7jvHvqEDbBB7ctMPqingKmLC5AeM1iR3nUPatr03DwxkZT8pW8ltTEvtkWo6hy'
api_secret = '6jsbp7bRfyqm98c4UIBq5oVIW8yrku7Q9s2SpEz39R1UEQz1CZtudZjysgpe45W6'
binance = ccxt.binance({'apiKey': api_key, 'secret': api_secret, 'enableRateLimit': True})

TOKEN = '7708635783:AAHnHSoPUV1AfhlpTDm3zOp795GkFi3xEHI'
CHAT_ID = '6031049850'
BASE_URL = f'https://api.telegram.org/bot{TOKEN}'
tz = pytz.timezone('Africa/Algiers')

OPEN_FILE = 'open_trades.json'
CLOSED_FILE = 'closed_trades.json'

# ===== Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© =====
def load_json(file):
    if not os.path.exists(file):
        return []
    with open(file, 'r') as f:
        content = f.read().strip()
        if not content:
            return []
        try:
            return json.loads(content)
        except json.JSONDecodeError:
            return []

def save_json(file, data):
    with open(file, 'w') as f: json.dump(data, f, indent=2)

open_trades = load_json(OPEN_FILE)
closed_trades = load_json(CLOSED_FILE)

def send(msg, reply_markup=None):
    data = {'chat_id': CHAT_ID, 'text': msg, 'parse_mode': 'HTML'}
    if reply_markup:
        data['reply_markup'] = json.dumps(reply_markup)
    requests.post(f'{BASE_URL}/sendMessage', data=data)

def send_keyboard():
    keyboard = {
        "keyboard": [[
            {"text": "ğŸ“Š Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©"},
            {"text": "ğŸ“ˆ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"},
            {"text": "ğŸ“‰ Ù†Ø³Ø¨Ø© Ø§Ù„ØµÙÙ‚Ø§Øª"}
        ]],
        "resize_keyboard": True
    }
    send('ğŸ§­ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:', reply_markup=keyboard)

def now():
    return datetime.now(tz).strftime('%Y-%m-%d %H:%M')

# ===== Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª =====
def handle_updates():
    last_id = None
    while True:
        try:
            res = requests.get(f"{BASE_URL}/getUpdates?offset={(last_id or 0)+1}&timeout=3").json()
            for upd in res.get("result", []):
                last_id = upd['update_id']
                msg = upd.get("message", {}).get("text", "")
                if not msg: continue

                if msg == "ğŸ“Š Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©":
                    if not open_trades:
                        send("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§.")
                    else:
                        for t in open_trades:
                            send(f"""ğŸ”„ ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø©

ğŸ“Œ Ø§Ù„Ø¹Ù…Ù„Ø©: {t['symbol']}
ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„: {t['entry']}
ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: {t['target']}
ğŸ›‘ Ø§Ù„Ø³ØªÙˆØ¨: {t['stop']}
ğŸ•’ ÙˆÙ‚Øª Ø§Ù„Ø¯Ø®ÙˆÙ„: {t['time']}
""")
                elif msg == "ğŸ“ˆ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª":
                    today = datetime.now(tz).strftime('%Y-%m-%d')
                    stats = ""
                    for t in closed_trades:
                        if today in t['time']:
                            if t.get("result") == "target":
                                stats += f"{t['symbol']} ğŸŸ¢ Ø±Ø¨Ø­ +1.25%\n"
                            elif t.get("result") == "stop":
                                stats += f"{t['symbol']} ğŸ”´ Ø®Ø³Ø§Ø±Ø© -5%\n"
                    send(f"ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ… {today}:\n\n{stats}" if stats else "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø§Øª Ù…ØºÙ„Ù‚Ø© Ø§Ù„ÙŠÙˆÙ….")
                elif msg == "ğŸ“‰ Ù†Ø³Ø¨Ø© Ø§Ù„ØµÙÙ‚Ø§Øª":
                    tickers = binance.fetch_tickers()
                    for t in open_trades:
                        symbol = t['symbol']
                        price = tickers[symbol].get('last')
                        if price:
                            change = round((price - t['entry']) / t['entry'] * 100, 2)
                            sign = "ğŸ“ˆ" if change > 0 else "ğŸ“‰"
                            send(f"{symbol} Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºÙŠØ±: {change}% {sign}")
        except Exception as e:
            print("Update error:", e)
        time.sleep(0.8)

# ===== Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ­Ù‚Ù‚ Ø§Ù„Ù‡Ø¯Ù Ø£Ùˆ Ø§Ù„Ø³ØªÙˆØ¨ =====
def check_trade_status(trade):
    try:
        symbol = trade.get('symbol')
        entry = trade.get('entry')
        target = trade.get('target')
        stop = trade.get('stop')
        if not all([symbol, entry, target, stop]):
            return None
        entry_time = datetime.strptime(trade['time'], '%Y-%m-%d %H:%M')
        entry_time = tz.localize(entry_time)
        since = int(entry_time.timestamp() * 1000)
        ohlcv = binance.fetch_ohlcv(symbol, '1m', since=since)
        for candle in ohlcv:
            high = candle[2]
            low = candle[3]
            if high >= target:
                return 'target'
            if low <= stop:
                return 'stop'
    except Exception as e:
        print("Check error:", e)
    return None

def monitor_trades():
    global open_trades, closed_trades, last_sold_candle
    while True:
        updated = []
        for trade in open_trades:
            result = check_trade_status(trade)
            if result:
                entry_time = tz.localize(datetime.strptime(trade['time'], '%Y-%m-%d %H:%M'))
                duration = round((datetime.now(tz) - entry_time).total_seconds() / 60)

                if result == 'target':
                    msg = f"âœ… Ø§Ù„ØµÙÙ‚Ø© Ø­Ù‚Ù‚Øª Ø§Ù„Ù‡Ø¯Ù!\n\nğŸ“Œ Ø§Ù„Ø¹Ù…Ù„Ø©: {trade['symbol']}\nğŸ“ˆ Ø§Ù„Ø±Ø¨Ø­: +1.25% ğŸŸ¢\nâ° Ø§Ù„Ù…Ø¯Ø©: {duration} Ø¯Ù‚ÙŠÙ‚Ø©"
                else:
                    msg = f"ğŸ›‘ Ø§Ù„ØµÙÙ‚Ø© Ø¶Ø±Ø¨Øª Ø§Ù„Ø³ØªÙˆØ¨!\n\nğŸ“Œ Ø§Ù„Ø¹Ù…Ù„Ø©: {trade['symbol']}\nğŸ“‰ Ø§Ù„Ø®Ø³Ø§Ø±Ø©: -5% ğŸ”´\nâ° Ø§Ù„Ù…Ø¯Ø©: {duration} Ø¯Ù‚ÙŠÙ‚Ø©"

                send(msg)

                trade["result"] = result
                closed_trades.append(trade)
            else:
                updated.append(trade)

        open_trades = updated
        save_json(OPEN_FILE, open_trades)
        save_json(CLOSED_FILE, closed_trades)
        time.sleep(2)

# ===== Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹ ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙØ±Øµ =====
last_bought_candle = {}
last_sold_candle = {}
last_open_price = {}
highest_change = {}

def analyze_symbol(symbol):
    try:
        ohlcv = binance.fetch_ohlcv(symbol, '15m', limit=2)
        if len(ohlcv) < 2:
            return

        prev_candle = ohlcv[-2]
        last_candle = ohlcv[-1]

        candle_timestamp = last_candle[0]
        open_price = last_candle[1]
        last_price = last_candle[4]

        prev_open = prev_candle[1]
        prev_close = prev_candle[4]
        prev_change = (prev_close - prev_open) / prev_open * 100

        if prev_change > 3:
            return

        if symbol not in last_open_price or last_open_price[symbol]['timestamp'] != candle_timestamp:
            last_open_price[symbol] = {'timestamp': candle_timestamp, 'open': open_price}
            highest_change[symbol] = -999

        open_price_fixed = last_open_price[symbol]['open']
        change = (last_price - open_price_fixed) / open_price_fixed * 100

        if change > highest_change[symbol]:
            highest_change[symbol] = change

        if 3.80 <= change < 3.95 and change >= highest_change[symbol] - 0.05:
            if (symbol in last_bought_candle and last_bought_candle[symbol] == candle_timestamp) \
               or (symbol in last_sold_candle and last_sold_candle[symbol] == candle_timestamp):
                return

            last_bought_candle[symbol] = candle_timestamp

            target_price = round(last_price * 1.0125, 6)
            stop_price = round(last_price * 0.95, 6)

            send(f"ğŸ”” Ø´Ø±Ø· Ø§Ù„Ø´Ø±Ø§Ø¡ ØªØ­Ù‚Ù‚ Ù„Ù€ {symbol} Ø¨Ø§Ø±ØªÙØ§Ø¹ {change:.2f}%\nğŸ¯ Ù‡Ø¯Ù: {target_price}\nğŸ›‘ Ø³ØªÙˆØ¨: {stop_price}")

            new_trade = {
                "symbol": symbol,
                "entry": last_price,
                "target": target_price,
                "stop": stop_price,
                "time": now(),
                "result": None
            }
            open_trades.append(new_trade)
            save_json(OPEN_FILE, open_trades)

    except Exception as e:
        print(f"Error analyzing {symbol}: {e}")

def scan():
    global open_trades
    while True:
        try:
            tickers = binance.fetch_tickers()
            active_symbols = []
            for symbol, data in tickers.items():
                if not symbol.endswith('/USDT'):
                    continue
                change_24h = data.get('percentage', 0)
                if change_24h is None or change_24h < -0.5:
                    continue
                vol = data.get('quoteVolume', 0)
                if vol < 600_000:
                    continue
                active_symbols.append(symbol)

            threads = []
            for symbol in active_symbols:
                t = Thread(target=analyze_symbol, args=(symbol,))
                t.start()
                threads.append(t)
            for t in threads:
                t.join()
        except Exception as e:
            print("Scan error:", e)
        time.sleep(2)

# ===== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª =====
send("âœ… ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª (ÙˆØ¶Ø¹ ØªØ¬Ø±ÙŠØ¨ÙŠ Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø§Ø¡/Ø¨ÙŠØ¹).")
send_keyboard()

Thread(target=scan).start()
Thread(target=handle_updates).start()
Thread(target=monitor_trades).start()
